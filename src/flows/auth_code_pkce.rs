//! Authorization Code + PKCE flow orchestration helpers and state carriers.
//!
//! These routines keep the most error-prone pieces of the handshake (state generation,
//! PKCE bookkeeping, token exchange, and persistence) behind the [`Broker`] facade so
//! application code can focus on redirect plumbing.
//!
//! The `AuthorizationSession` returned by [`Broker::start_authorization`] is designed to
//! be serialized and stored by callers between the authorize redirect and the callback
//! handler so replayed states or swapped principals can be rejected immediately.

mod session;

pub use session::*;

// self
use crate::{
	_prelude::*,
	auth::{PrincipalId, ScopeSet, TenantId, TokenFamily, TokenRecord},
	error::ConfigError,
	flows::Broker,
	http::TokenHttpClient,
	oauth::{BasicFacade, OAuth2Facade, TransportErrorMapper},
	obs::{self, FlowKind, FlowOutcome, FlowSpan},
	provider::GrantType,
	store::BrokerStore,
};

impl<C, M> Broker<C, M>
where
	C: ?Sized + TokenHttpClient,
	M: ?Sized + TransportErrorMapper<C::TransportError>,
{
	/// Generates an Authorization Code + PKCE session for the provided tenant context.
	///
	/// Calling this method verifies that the backing descriptor advertises
	/// `authorization_code` support, builds a cryptographically strong `state`, and
	/// attaches a PKCE verifier/challenge pair. The resulting [`AuthorizationSession`]
	/// exposes accessor methods that UI layers can use to embed the authorize URL in a
	/// link or form, while backend handlers can persist the tenant/principal/scope
	/// context alongside the opaque state for later validation.
	///
	/// The broker does **not** automatically persist the session — it is the caller’s
	/// responsibility to stash it (or the relevant fields) until the redirect round-trip
	/// completes so [`AuthorizationSession::validate_state`] can run before an exchange.
	pub fn start_authorization(
		&self,
		tenant: TenantId,
		principal: PrincipalId,
		scope: ScopeSet,
		redirect_uri: Url,
	) -> Result<AuthorizationSession> {
		const KIND: FlowKind = FlowKind::AuthorizationCode;

		let _span = FlowSpan::new(KIND, "start_authorization").entered();

		obs::record_flow_outcome(KIND, FlowOutcome::Attempt);

		let result = (|| -> Result<AuthorizationSession> {
			self.ensure_authorization_code_supported()?;
			Ok(build_session(
				&self.descriptor,
				self.client_id.as_str(),
				tenant,
				principal,
				scope,
				redirect_uri,
			))
		})();

		match &result {
			Ok(_) => obs::record_flow_outcome(KIND, FlowOutcome::Success),
			Err(_) => obs::record_flow_outcome(KIND, FlowOutcome::Failure),
		}
		result
	}

	/// Exchanges an authorization code + PKCE verifier for broker-managed tokens.
	///
	/// The `AuthorizationSession` generated by [`Broker::start_authorization`] carries
	/// the tenant/principal/scope context, redirect URI, and PKCE verifier needed to
	/// process the callback. Once the provider redirects back with a code, call this
	/// method with the original session and the returned `code`. Successful exchanges
	/// emit a [`TokenRecord`] that has already been written to the configured
	/// [`BrokerStore`](crate::store::BrokerStore) so subsequent fetches observe the
	/// latest secrets.
	pub async fn exchange_code(
		&self,
		session: AuthorizationSession,
		authorization_code: impl AsRef<str>,
	) -> Result<TokenRecord> {
		const KIND: FlowKind = FlowKind::AuthorizationCode;

		let span = FlowSpan::new(KIND, "exchange_code");

		obs::record_flow_outcome(KIND, FlowOutcome::Attempt);

		let result = span
			.instrument(async move {
				self.ensure_authorization_code_supported()?;
				let (tenant, principal, requested_scope, redirect_uri, pkce) =
					session.into_exchange_parts();
				let mut family = TokenFamily::new(tenant, principal);

				family.provider = Some(self.descriptor.id.clone());

				let facade: BasicFacade<C, M> = BasicFacade::from_descriptor(
					&self.descriptor,
					&self.client_id,
					self.client_secret.as_deref(),
					Some(&redirect_uri),
					self.http_client.clone(),
					self.transport_mapper.clone(),
				)?;
				let record = facade
					.exchange_authorization_code(
						self.strategy.as_ref(),
						family,
						authorization_code.as_ref(),
						&pkce.verifier,
						&requested_scope,
						&redirect_uri,
					)
					.await?;

				<dyn BrokerStore>::save(self.store.as_ref(), record.clone())
					.await
					.map_err(Error::from)?;

				Ok(record)
			})
			.await;

		match &result {
			Ok(_) => obs::record_flow_outcome(KIND, FlowOutcome::Success),
			Err(_) => obs::record_flow_outcome(KIND, FlowOutcome::Failure),
		}

		result
	}

	fn ensure_authorization_code_supported(&self) -> Result<()> {
		if self.descriptor.supports(GrantType::AuthorizationCode) {
			Ok(())
		} else {
			Err(ConfigError::UnsupportedGrant {
				descriptor: self.descriptor.id.to_string(),
				grant: "authorization_code",
			}
			.into())
		}
	}
}
